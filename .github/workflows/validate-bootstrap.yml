name: Validate Bootstrap Manifests

on:
  pull_request:
    branches:
      - main
    paths:
      - "bootstrap/**"
      - "argocd/**"
      - ".github/workflows/validate-bootstrap.yml"

jobs:
  static-analysis:
    runs-on: ubuntu-latest
    name: Static Analysis

    # Expose yamllint info to the summary job
    outputs:
      yamllint_status: ${{ steps.yamllint.outputs.yamllint_status }}
      yamllint_output: ${{ steps.yamllint.outputs.yamllint_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed YAML files (vs base branch)
        id: changed-files
        shell: bash
        env:
          # For PRs this is the target branch (e.g. main/master); for other events it's empty.
          BASE_REF: ${{ github.base_ref }}
        run: |
          set -euo pipefail

          base="${BASE_REF:-main}"
          echo "Base branch: $base"

          # Make sure the base branch exists locally as refs/remotes/origin/<base>
          git fetch --no-tags --prune origin "+refs/heads/${base}:refs/remotes/origin/${base}"

          # Sanity check: ensure the ref exists now
          git rev-parse --verify "refs/remotes/origin/${base}" >/dev/null

          # Diff merge-base (good for PRs): origin/<base>...HEAD
          changed="$(
            git diff --name-only --diff-filter=ACMRT "origin/${base}...HEAD" -- \
              'bootstrap/**' \
              'argocd/**' \
            | grep -E '\.(ya?ml)$' \
            || true
          )"

          echo "Changed YAML files:"
          printf '%s\n' "$changed"

          {
            echo "changed_files<<EOF"
            printf '%s\n' "$changed"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          if [ -z "$changed" ]; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Run yamllint on changed files
        id: yamllint
        if: steps.changed-files.outputs.has_changes == 'true'
        shell: bash
        run: |
          set -euo pipefail

          changed_files="${{ steps.changed-files.outputs.changed_files }}"
          mapfile -t files <<<"$changed_files"

          files_to_lint=()
          for f in "${files[@]}"; do
            # trim leading whitespace
            f="${f#"${f%%[![:space:]]*}"}"
            # trim trailing whitespace
            f="${f%"${f##*[![:space:]]}"}"
            [ -n "$f" ] && files_to_lint+=("$f")
          done

          if [ ${#files_to_lint[@]} -eq 0 ]; then
            echo "yamllint_status=SKIPPED" >> "$GITHUB_OUTPUT"
            {
              echo "yamllint_output<<EOF"
              echo "No YAML files to lint."
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Linting files:"
          printf '%s\n' "${files_to_lint[@]}"

          # Capture raw yamllint output in a parseable format.
          # Do not rely on exit code for pass/warn/fail classification; classify by content.
          set +e
          output="$(yamllint -f parsable -c .yamllint "${files_to_lint[@]}" 2>&1)"
          rc=$?
          set -e

          errors_count="$(printf '%s\n' "$output" | grep -c '\[error\]' || true)"
          warnings_count="$(printf '%s\n' "$output" | grep -c '\[warning\]' || true)"

          status="PASSED"
          if [ "$errors_count" -gt 0 ]; then
            status="FAILED"
          elif [ "$warnings_count" -gt 0 ]; then
            status="WARNINGS"
          else
            # If yamllint exited nonzero but didn't emit the usual markers, treat it as a tool/config failure
            if [ "$rc" -ne 0 ] && [ -n "$output" ]; then
              status="FAILED"
            fi
          fi

          echo "yamllint_status=$status" >> "$GITHUB_OUTPUT"
          {
            echo "yamllint_output<<EOF"
            if [ -n "$output" ]; then
              printf '%s\n' "$output"
            else
              echo "No findings."
            fi
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          # Always exit 0 here so the validation-summary job can post a comment even when yamllint fails.
          exit 0

      - name: Install kubeconform
        if: steps.changed-files.outputs.has_changes == 'true'
        run: |
          wget https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz
          tar xf kubeconform-linux-amd64.tar.gz
          sudo mv kubeconform /usr/local/bin/

      - name: Validate Kubernetes schemas on changed files
        if: steps.changed-files.outputs.has_changes == 'true'
        run: |
          set -euo pipefail
          changed_files="${{ steps.changed-files.outputs.changed_files }}"
          errors=0
          echo "$changed_files" | grep -v kustomization.yaml | while read -r file; do
            [ -z "$file" ] && continue
            output=$(kubeconform -strict "$file" 2>&1 || true)
            if echo "$output" | grep -qE "error|ERROR"; then
              echo "::error file=$file::Schema Validation: $output"
              errors=1
            fi
          done
          [ $errors -eq 1 ] && exit 1

  build-validation:
    runs-on: ubuntu-latest
    name: Build Validation
    needs: static-analysis
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Validate Kustomize build - bootstrap
        run: |
          kustomize build bootstrap/ > /dev/null

      - name: Validate Kustomize build - argocd
        run: |
          kustomize build argocd/ > /dev/null

  deployment-readiness:
    runs-on: ubuntu-latest
    name: Deployment Readiness
    needs: build-validation
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate CRD ordering
        run: |
          if [ ! -d "bootstrap/crds/" ]; then
            exit 1
          fi

  validation-summary:
    runs-on: ubuntu-latest
    name: Validation Summary
    needs: [static-analysis, build-validation, deployment-readiness]
    if: always()
    permissions:
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Generate validation report
        id: report
        run: |
          static_status="${{ needs.static-analysis.result }}"
          build_status="${{ needs.build-validation.result }}"
          deployment_status="${{ needs.deployment-readiness.result }}"

          overall="passed"
          if [ "$static_status" != "success" ] || [ "$build_status" != "success" ] || [ "$deployment_status" != "success" ]; then
            overall="failed"
          fi

          layer1_status=$([ "$static_status" = "success" ] && echo "passed" || echo "failed")
          layer2_status=$([ "$build_status" = "success" ] && echo "passed" || echo "failed")
          layer3_status=$([ "$deployment_status" = "success" ] && echo "passed" || echo "failed")

          echo "overall=$overall" >> $GITHUB_OUTPUT
          echo "layer1_status=$layer1_status" >> $GITHUB_OUTPUT
          echo "layer2_status=$layer2_status" >> $GITHUB_OUTPUT
          echo "layer3_status=$layer3_status" >> $GITHUB_OUTPUT

      - name: Generate app token
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.CI_APP_ID }}
          private-key: ${{ secrets.CI_APP_PRIVATE_KEY }}

      - name: Post validation summary to PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            function status(s) {
              return s === "passed" ? "✅ PASSED" : "❌ FAILED";
            }

            function yamllintBadge(s) {
              if (s === "FAILED") return "❌ FAILED";
              if (s === "WARNINGS") return "⚠️ WARNINGS";
              if (s === "SKIPPED") return "➖ SKIPPED";
              return "✅ PASSED";
            }

            const overall = status(`${{ steps.report.outputs.overall }}`);
            const layer1 = status(`${{ steps.report.outputs.layer1_status }}`);
            const layer2 = status(`${{ steps.report.outputs.layer2_status }}`);
            const layer3 = status(`${{ steps.report.outputs.layer3_status }}`);

            const yamllintStatus = `${{ needs.static-analysis.outputs.yamllint_status }}` || "SKIPPED";
            const yamllintOutputRaw = `${{ needs.static-analysis.outputs.yamllint_output }}` || "";

            const yamllintSection =
              `\n\n### Yamllint (changed files)\n- Result: ${yamllintBadge(yamllintStatus)}\n` +
              (yamllintOutputRaw.trim()
                ? `\n\`\`\`\n${yamllintOutputRaw}\n\`\`\`\n`
                : "\n_No output._\n");

            const report = `# CI Pipeline Validation Report

            ## Overall Status: ${overall}

            ### Layer 1: Static Analysis
            - Status: ${layer1}${yamllintSection}

            ### Layer 2: Build & Integration
            - Status: ${layer2}

            ### Layer 3: Deployment Readiness
            - Status: ${layer3}
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });

      - name: Check validation results
        run: |
          # Fail if any core job failed or if yamllint has ERRORS.
          if [ "${{ needs.static-analysis.result }}" != "success" ] || \
             [ "${{ needs.build-validation.result }}" != "success" ] || \
             [ "${{ needs.deployment-readiness.result }}" != "success" ] || \
             [ "${{ needs.static-analysis.outputs.yamllint_status }}" = "FAILED" ]; then
            exit 1
          fi
